<?php
    $PAGE_NAME = 'Javascript';
    require_once($_SERVER["DOCUMENT_ROOT"].'/javascript/javascripthead.php');
?>
<main class="pure-u-1 pure-u-sm-19-24 pure-u-md-17-24 pure-u-lg-5-8 pure-u-xl-5-8">
	<section>
		<h4>Navigating the Javascript Section</h4>
		<p>On every page in this section, on the left side of the screen you will find links to pages for most of the major objects used in Javascript, as well as one on the complex uses of the <code>&lt;canvas&gt;</code> element. Each page will have a brief description of the object as well as lists of the properties and methods associated with it. Additionally, below those sections is one on jQuery, a popular Javascript library which provides a number of ways to make scripts faster and easier to write. On this page, you will also find explanations of the more basic concepts in Javascript.</p>
		</p><strong>Important</strong> note on the pages here: each section of properties and methods is labeled as 'Object' or 'Type'. Object properties/methods are addressed at the global object, i.e. <code>Math.random</code>, while type properties/methods are addressed at any object of that type and <em>not</em> the global object, i.e. <code><var>myString</var>.trim()</code>. In the jQuery pages, each section of properties and methods is prefaced by what object they can be chained from, if any other than the jQuery object.</p>
	</section>
	<section>
		<h4>What is Javascript?</h4>
		<p>Javascript, also known as JavaScript or just JS/js, is a scripting language implemented in all web browsers. While HTML provides the pieces of the page and CSS governs their look and arrangement, Javascript provides the motion, being able to continue running in the background, changing the page, even having the ability to rewrite its contents entirely. It's an interpreted language, meaning it doesn't need to be run through a separate compiler program before it can be run. Technically speaking, the process of conversion between human-readable script and machine code still happens, but it happens in real-time as the web browser executes Javascript instructions rather than as a separate step the programmer has to take. It is also a typeless language, meaning that it is not nearly so strict over whether specific pieces of data are strings, integers, booleans etc. Everything in Javascript is actually an 'object' in strict terms, with its apparent types coming from specific sets of properties set on them. But while literally true, the 'typeless' designation is somewhat misleading, because this simulated approach to typing <em>does</em> still matter in Javascript - there are clear differences in how things marked as one type or another behave, and what can be done with them, it's just not nearly as exacting. One fairly common thing to see in Javascript is methods or especially operators which behave differently depending on the types of objects provided to them.</p>
	</section>
	<section>
		<h4>What is jQuery?</h4>
		<p>jQuery is a JavaScript library - technically speaking, it's a large, complex script which adds new objects and methods that can be used alongside traditional Javascript objects and methods. It is not separate from Javascript; it seamlessly integrates with normal JS scripts, and as long as jQuery is loaded before those scripts are run, they will be able to make use of its functionality. jQuery is generally useful for making certain aspects of Javascript faster and simpler to write, particularly when it comes to AJAX requests (requesting file data from a server) and DOM manipulation (changing visible elements on the webpage). Note that because jQuery statements always begin with a reference to the jQuery object, many of its methods appear to be usable with elements that don't have those methods defined on themselves.</p>
	</section>
	<section>
		<h4>How it Works</h4>
		<p>Just as with HTML and CSS, when you load a webpage, any Javascript scripts on the page will also be loaded into your browser, which will faithfully interpret and execute the instructions given to it. Modern web browsers have generally been set up to execute their instructions very efficiently, so the actual process of running through a JS script is a lot faster than you'd expect just looking at what it has to do! For this reason, it's generally held to be the case that when writing scripts, obviously you want to avoid things that majorly drain performance, but keeping it clean, readable, and maintainable by yourself and any relevant teams is much more important than making everything flawlessly efficient. As with anything, there are exceptions, but for the most part the browser will probably do a better job of interpreting the code to be efficient than most programmers would anyway!</p>
	</section>
	<section>
		<h4>Syntax - How to Write Javascript Code</h4>
		<p>As with the other two major web languages, Javascript's syntax is much more lenient than what is found in compiled languages. Spacing, tabbing, and new lines don't matter, as long as everything is properly opened and closed - don't forget to put the ) after the } if you have a function block inside a method's parameters! One thing in Javascript syntax is a little more uncertain though, and that is the use of the semicolon. Semicolons are placed after Javascript statements, which encompasses nearly everything that can appear on a line in a script, but their purpose is to separate said statements. As such, they may be omitted if that statement is the only one inside of a bracket container of any kind, or if there is a line break immediately afterward. However, even though semicolons can technically be safely omitted before a line break, doing so is considered bad practice, partially because many companies put Javascript intended to be served to thousands of users through a 'minification' process which removes things like spaces and line breaks!</p>
		<p>One other key concept is that of the 'return value'. Anything that occurs during a Javascript statement is an instruction to the web browser, and its return value is the value the web browser returns after executing it. This is often an object or a value, but may also be nothing, <code>undefined</code> in technical terms, meaning no return value was defined. Functions, methods, references to properties, even just an object name like <code>window</code> will actually cause the web browser to return what it deems appropriate - in that case, it would be the <code>window</code> object itself. Furthermore, this can be used to 'chain' statements together with a period; <code>window.status</code> first returns the <code>window</code> object, then attempts to retrieve the value of <code>status</code>, as it is defined in the context of the <code>window</code> object, and returns that! A chain can be continued as long as each return value is still an appropriate place to begin for the next component of the chain, but it is best to keep this kind of thing to a minimum because long, unnecessary chains make code harder to read and aren't meaningfully more efficient in most cases.
		<p>However, there is one other aspect of this approach which allows far more flexibility than chaining. Because everything is executed as it is found in the code, it is possible to nest methods and functions within each other, or even within themselves, with virtually no depth limit. You can define a new function inside the argument of a method which is meant to operate on a string, and as long as that function ultimately returns a string, everything works out. However, as with everything else, keep your code readable - getting too clever with this kind of thing can make it very difficult for someone reading through the script (or even you, if you look back at it again after enough time has passed) to follow which logic is doing what.</p>
	</section>
	<section>
		<h4>Scope</h4>
		<p>One of the fundamental things to keep in mind with Javascript is function scope. Anything that occurs inside of a function, including variable declarations, is effectively owned by that function and can't be directly requested or affected by any other function. Those declarations are inherited by functions and methods <em>within</em> that function, but are not available to their parent. Notably, this includes something like a function defined in the parent, then called within the child - it will still only have access to what was available where it was defined, although this can be worked around by passing the function scoped values into its arguments. This can be frustrating to keep straight at times, but is necessary for many reasons, among them security and making sure there is a clear, logical path in the code to where everything was defined. As a result, however, avoid defining variables, functions, or anything else in any scope higher than the one in which it will be used.</p>
	</section>
	<section>
		<h4>When Your Code Will Run</h4>
		<p>So let's say you have a script on your page that, as an arbitrary example, tallies the contents of a number of user-editable boxes and displays the sum. When do you want it to run? When the user clicks the button to calculate? But wait! If you were following good practices, the script that does this is located in the page's <code>&lt;head&gt;</code> area - earlier on the page than the button. This introduces what's called a 'race condition' - one where the behavior will change depending on what finishes first, in this case, which will be loaded first, the script or the button? To avoid this, scripts that load with the page very commonly have all of their logic nested inside of a function which only runs when the <a href="/javascript/document.php"><code>document</code></a> object experiences the <code>load</code> <a href="/javascript/event.php">event</a>, i.e. the entire page is now loaded and the script doesn't have to worry about whether or not the page elements it refers to will actually be there when it runs.</p>
	</section>
</main>	
<?php
    require_once($_SERVER["DOCUMENT_ROOT"].'/genericfoot.php');
?>
